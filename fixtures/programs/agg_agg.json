{"noir_version":"1.0.0-beta.7+24c053fba747770cf8d3f813d22cfa003714dfb6","hash":"3194531293726529424","abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"verification_key_hash","type":{"kind":"field"},"visibility":"public"},{"name":"utxo_agg_proofs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"UtxoAggProof","fields":[{"name":"proof","type":{"kind":"array","length":456,"type":{"kind":"field"}}},{"name":"old_root","type":{"kind":"field"}},{"name":"new_root","type":{"kind":"field"}},{"name":"commit_hash","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"old_root","type":{"kind":"field"},"visibility":"public"},{"name":"new_root","type":{"kind":"field"},"visibility":"public"},{"name":"commit_hash","type":{"kind":"field"},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":36,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"nVbLjsIwDPyXnDnEzsPJ/spqhQoEVKkqqLRIK8S/b3g4wCEV65PbpjMZT203Z7VJq2m3bPvt/qi+vs9qNbRd1+6W3X7djO2+z0/Pl4Xi2+U4pJQfqZf1jDo0Q+pH9dVPXbdQp6abbi8dD01/i2Mz5FW9UKnf5JgJt22XrleXxROt61Ab4QF2Oha4s5/inTOM9yJ8YLzXRoD3QIw3JME7zt8TSPDBPfCknQBPEBlvJP5R8Z9I4h8F9i9oiX8B2b9gJf4Fx/4FkvgXAvsXQQvwES3jrWT/6Mr+QbR/5P1Bg0QAaIyFwWkRg39qCDINsWgAFGkAUzSAE2lAz50A1lRbAecovOFiBIJQKBA/FmGfn9OFaj8j1ikM8TS3xj4lvA90NHUCNMBGoEFfpbBzXyN4TgNffgv/UUGW80By9UT8jAqKPJsgQD0RmumuUhORRASgSxq5N6IojWhKYUZbVTFbVRRrVfWT75p1O7ydK5TO9Hkuwz1gDpnA3IO9B5dL7TqwT83QNqsuPc4j26lfvxxPxt8Dr/AB5jDs12kzDem65W0ti/gD","file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"54":{"source":"use dep::std;\nuse std::hash::poseidon2;\n\nstruct UtxoAggProof {\n    proof: [Field; 456],\n    old_root: Field,\n    new_root: Field,\n    commit_hash: Field\n}\n\nfn main(\n    verification_key: [Field; 128],\n    verification_key_hash: pub Field,\n    utxo_agg_proofs: [UtxoAggProof; 2],\n    old_root: pub Field,\n    new_root: pub Field,\n    commit_hash: pub Field,\n    // 6 proofs, 6 per proof\n    messages: pub [Field; 36],\n) {\n    let mut root = old_root;\n\n    for i in 0..2 {\n        let proof = utxo_agg_proofs[i];\n        let public_inputs = [\n            messages[18 * i],\n            messages[18 * i + 1],\n            messages[18 * i + 2],\n            messages[18 * i + 3],\n            messages[18 * i + 4],\n            messages[18 * i + 5],\n            messages[18 * i + 6],\n            messages[18 * i + 7],\n            messages[18 * i + 8],\n            messages[18 * i + 9],\n            messages[18 * i + 10],\n            messages[18 * i + 11],\n            messages[18 * i + 12],\n            messages[18 * i + 13],\n            messages[18 * i + 14],\n            messages[18 * i + 15],\n            messages[18 * i + 16],\n            messages[18 * i + 17],\n            proof.old_root,\n            proof.new_root,\n            proof.commit_hash\n        ];\n\n        std::verify_proof_with_type(\n            verification_key,\n            proof.proof,\n            public_inputs,\n            verification_key_hash,\n            1,\n        );\n\n        root = new_root;\n    }\n\n    assert(commit_hash == poseidon2::Poseidon2::hash([utxo_agg_proofs[0].commit_hash, utxo_agg_proofs[1].commit_hash], 2));\n    assert(new_root == root, \"Roots must match\");\n}\n","path":"/Users/calummoore/projects/polybase/payy/noir/agg_agg/src/main.nr"}},"names":["main"],"brillig_names":[]}