{"noir_version":"1.0.0-beta.7+24c053fba747770cf8d3f813d22cfa003714dfb6","hash":"743223003709483108","abi":{"parameters":[{"name":"notes","type":{"kind":"array","length":10,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"secret_keys","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"private"},{"name":"address","type":{"kind":"field"},"visibility":"private"},{"name":"timestamp","type":{"kind":"field"},"visibility":"public"},{"name":"value","type":{"kind":"field"},"visibility":"public"},{"name":"hash","type":{"kind":"field"},"visibility":"public"},{"name":"commitments","type":{"kind":"array","length":10,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"1714809443410094063":{"error_kind":"string","string":"Padding notes must be zero value"},"3898381286344942305":{"error_kind":"string","string":"Input note is not owned by the owner"},"6661914514907183551":{"error_kind":"string","string":"Note commitment is not valid"},"12506305391274039017":{"error_kind":"string","string":"Invalid value"}}},"bytecode":"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","debug_symbols":"pVhbbuMwDLyLv/MhPkRKvcpiUaStWwQI0iJNCiyK3n1lk8pjARle+yejxCXHGs2wib+7l/7p/Pa4O7y+f3YPv767p+Nuv9+9Pe7fn7en3fuhfPr9s+nq28fTse/LR93N9VL1sT32h1P3cDjv95vua7s/j3/0+bE9jHjaHsvVsOn6w0vB0vB1t++H1c/mWh3apaTixZT4Uh5lbj0DeD1jXFIfsdaLLKlX9foI0Krndj1e9x9u6vGuPv73/ufXM9f6mBfUR8xeL0Fb9Wnq/Kt5mK7nj/f+yRP6EZA3QEJpdYCJIwSi2gKo3HmrBbRbZKkdssqSBhC46gAh5SVCaKgniQravAleL0RcK8S8BpkWnSakmijAsEzJy1mgxqYpYaIFaK5jARI0hcCwUsmpBjMtNbmNfDVE5uZdzBtv0BxPYWq81PEWNbfGK074SVM9iATUuoGpBoljbaDNAYnabiCXCac3Tvi3wdoRietnJK2fkbR2Rk7pwCAXHWiRDvOCTbw62BRX53LyLublcp6tc5Alwcx1EwJLvncJVX6Ji+ovU15Jm9+7YGWqGFenimn1/6rJu5jnaY6rPc2yMttTDWaGYnIb80Ixz1N878nf5d32eXe8+/XUhVKy6WB8xfGVSumm42FIbrpoIOUWygGqQSpQkp0LDLXBERxLGxqQHNkxDr+PCopRqkEyyCMrBuNDMCZERzJKZOPA6CiOahyYjAOzbcV2R7Y9wpGDyDiIrTdFRzEOUutJydH3ycE4GIyDTS4mAzaIpp4YB7tinByzcUTXLLpmER1ds8jGEePYNZpk0SSLaeSI2c8mWG9xzQSNQ8h6imsmrpmIcYgah9gJiEmmJpnCyKFoHEpuANdMo3Go66+umbpmmo0jBeNIdgLJJEsmWeKRI7nHkpssVZe5zZLrn12z7Jpl91km48h2AtkkyyZZ1pEjJ+PI2XpDCHUBxgIBq52pLrguojs4iFs4uHmDuzeYeDBkQQcE4wNwAwNQXbATQqy5kbrQukhOOMRiJETPKYIjOlpaAT2vgO5mQKkLdUJMNaA1uVSjOyTEMotOOKRkGGcwxITHT0rnODwd+doed9unfe9PX17Ph+ebhzGnPx/1Sn1c83F8f+5fzsd+GD3jtTKM/gI=","file_map":{"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"52":{"source":"use std::hash::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash([note.kind, note.value, note.address, note.psi], 4)\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n","path":"/Users/calummoore/projects/polybase/payy/noir/common/src/lib.nr"},"56":{"source":"use common::{check_commitment, check_input_note_ownership, get_address, InputNote, Note};\nuse std::hash::poseidon2;\n\nfn main(\n    notes: [Note; 10],\n    secret_keys: [Field; 10],\n    address: Field,\n    timestamp: pub Field,\n    value: pub Field,\n    hash: pub Field,\n    commitments: pub [Field; 10],\n) {\n    let mut notes_value = 0;\n\n    for i in 0..10 {\n        let note = notes[i];\n        let secret_key = secret_keys[i];\n        let commitment = commitments[i];\n\n        check_commitment(note, commitment);\n        check_input_note_ownership(InputNote { note, secret_key });\n\n        notes_value += note.value;\n    }\n\n    assert(value == notes_value, \"Invalid value\");\n    assert(poseidon2::Poseidon2::hash([timestamp, address], 2) == hash);\n}\n\n#[test]\nfn test_main() {\n    let pk = 101;\n    let address = get_address(pk);\n\n    // Create 10 notes with the same address\n    let mut notes: [Note; 10] = [\n        Note { kind: 0, value: 0, address: 0, psi: 0 },\n        Note { kind: 1, value: 20, address: address, psi: 2 },\n        Note { kind: 1, value: 30, address: address, psi: 3 },\n        Note { kind: 1, value: 40, address: address, psi: 4 },\n        Note { kind: 1, value: 50, address: address, psi: 5 },\n        Note { kind: 1, value: 60, address: address, psi: 6 },\n        Note { kind: 1, value: 70, address: address, psi: 7 },\n        Note { kind: 1, value: 80, address: address, psi: 8 },\n        Note { kind: 1, value: 90, address: address, psi: 9 },\n        Note { kind: 1, value: 100, address: address, psi: 10 },\n    ];\n\n    // Calculate the total value of all notes\n    let total_value = 540;\n\n    // Create an array of secret keys (all the same in this test)\n    let mut secret_keys = [pk; 10];\n    secret_keys[0] = 0;\n\n    // Calculate commitments for each note\n    let mut commitments: [Field; 10] = [0; 10];\n    for i in 0..10 {\n        commitments[i] = common::get_note_commitment(notes[i]);\n    }\n\n    // Create timestamp and calculate hash\n    let timestamp = 10000000;\n    let message_hash = poseidon2::Poseidon2::hash([timestamp, address], 2);\n\n    main(\n        notes,\n        secret_keys,\n        address,\n        timestamp,\n        total_value,\n        message_hash,\n        commitments,\n    )\n}\n","path":"/Users/calummoore/projects/polybase/payy/noir/points/src/main.nr"}},"names":["main"],"brillig_names":["directive_invert"]}