{"noir_version":"1.0.0-beta.7+24c053fba747770cf8d3f813d22cfa003714dfb6","hash":"9140506487760559155","abi":{"parameters":[{"name":"input_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::InputNote","fields":[{"name":"note","type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},{"name":"secret_key","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"output_notes","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"common::Note","fields":[{"name":"kind","type":{"kind":"field"}},{"name":"value","type":{"kind":"field"}},{"name":"address","type":{"kind":"field"}},{"name":"psi","type":{"kind":"field"}}]}},"visibility":"private"},{"name":"pmessage4","type":{"kind":"field"},"visibility":"private"},{"name":"commitments","type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},{"name":"messages","type":{"kind":"array","length":6,"type":{"kind":"field"}},"visibility":"public"}],"return_type":null,"error_types":{"1714809443410094063":{"error_kind":"string","string":"Padding notes must be zero value"},"3404918372409612292":{"error_kind":"string","string":"Inconsistent kind in input/output notes at 1 index"},"3898381286344942305":{"error_kind":"string","string":"Input note is not owned by the owner"},"5851673573934815162":{"error_kind":"string","string":"Mint note kind must match message"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6661914514907183551":{"error_kind":"string","string":"Note commitment is not valid"},"9733062431596745772":{"error_kind":"string","string":"Input and output totals do not match"},"10238763455687985759":{"error_kind":"string","string":"Inconsistent kind in input/output notes at 0 index"},"10443210886677245255":{"error_kind":"string","string":"Burn note kind must match message"},"11367064451646183755":{"error_kind":"string","string":"Inconsistent kind in note"},"12948852497587922262":{"error_kind":"string","string":"messages[4] must match private input"},"14672809696058342244":{"error_kind":"string","string":"Burn output must match value message"},"15138347411163958997":{"error_kind":"string","string":"Mint hash must match message"},"15768116005382545724":{"error_kind":"string","string":"Inconsistent input kind is not allowed for burn"},"15819538689241197369":{"error_kind":"string","string":"Invalid kind"},"17828285616048074783":{"error_kind":"string","string":"Mint output must match value message"},"18075917454431129723":{"error_kind":"string","string":"Burn hash must match message"}}},"bytecode":"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","debug_symbols":"tVrRbmMpDP2X+5wHDAbD/MpqVaVtOooUpVWmHWlVzb+vfXvhtqvFy2LNS+029Ykx+IAN78vj6f7t+935+vT8Y/n2x/tyfztfLufvd5fnh+Pr+fnKf33/dVjqr3evt9OJ/7R8+pytXo630/V1+XZ9u1wOy8/j5W39px8vx+sqX483/tQdltP1kSUDPp0vJ9F+HXZr1zcNJW/GCL6Zx2F7hFLtQ5iwDxmaPfbsQ9/eU9rsg4Pd3n+xR83/9v0+ztgjVvtYJuyjr/FLjnr2pMSP3L/Ez3+NX1biFyBsAD741EMofQQIoSJAiL6HAMoiKKkiFEozAOCwhgFcLjNxIFcn0hNQ14lgDwRaAzEGUMLMZEKu+QTezQWyTYWn2F2SoEAAFapOZOjHoVgDWcwrSh1G2ddDwa4XY+QGXXLSyDnWOCLBDLlT2xzK1ObQYoiluzn4ZGR3T0Z6VwFG+F0DGCL44IwMH8BM8cGbqS0EY0ZqAIMZqUZijORDskeCrJEgI8mr0znG8nooh2gewUzz6I2h1AAGF5U6jDGaH6S5KZ6PUO1jmOH52EYQkWZ4vpRmn3v2WIw8H52R51WAEZ7XAIZ4PgYjz0c083yMZnaLyZiSGsBgSqqRGOP5aK9qkrWqGQTo87w6nWM8r4dyiOcTmnk+RWsoo3lRqcMY4/lBmpvjeaosF3Oa4fmcG0fNnOdjxGbfPc+TN/I8BSPPqwAjPK8BjDVskpHnicw8T9nMbmStsMleYauRGOP5bK9ssrWyGQTo87w6nWM8r4dyiOczmXk+Z2sos70RSGaeH6S5KZ5PAr7aE3R5tmgkRXUICfZLAcijDpCvGwWl0nUg/j4HwMc9Ld3MXgcxtJUQKc4g8NjbevbduqYUrbBq+xXXWDNOeBcaxTmcQghu3y4ApxBCaghTBaKnvBN1mRpFhkouXpkMDaHk/fARu6sanHXvBmffvJm8zHSv+zHYpldvXQb79ADWRr2GMNqpV0cyxvlalzaU6gWrZeYmFH1bn0q7HkBZnxF94xvEmSwJ+/k2UP9GGLSLDy5TmhcU8hxGBtdqnUBzGMXXfTQWLJMYeT/vY39WvHIcSNAuyRP0b8n/AyNCw0hTM0ufZjZMIeS2pYbcX+OgtTqHY5F+ayxKqgihZJxCwGhDQLdvJq5MXc9BO6CgnzokMeU0H3yaYS0M7aSHYWpnZ55qNX2caksgL4iKkMLUKCj6dlNKU5GkQEaEnJoPxc28peHoNd51fqpBBG0PioBuyof9LgAUvtQuZSjXUObP5Y8fR8gtOTOVPgJqJZhrJVjqI0TrWRGT/ayIZO5vAFqrcjUW2C6oPr8S+1+xGDyvRvuFI0T7haHux9hpc3CFF5cmWgwRCFue5jzFFUg7Qv80EMma6RrCWKZrNz1jmZ6sLzQg2Z9oQLJ3MiFZW5lqLMYyPdlfFkBK9kxPZM901Y/BTB9b4f/M9D/5t+PD+fblTfHi+MPDAutPv/4MvMgPC8qp+rDED5HYCZ4E+hBZ1t1hKdJcYVu3Sdikl+4JyyD1IUuUUxvLuMkkBy+WJFTAMm+yfEgvLvF3enGK8byXrGMZNsl4cpL1jCes5NMmaZOMRzKaIjzB43ESC5awScYrjB8Yr/D/B5SVzFLG6uQfUlWoKrkqRQpAHju6qkBVvCj8vRiqglURZGlIYUVGQZbSBnNVytqe4YgLskQ5QlUE2bOnMVRlnR1GjrEqqSqCLC/MYq7KisyBTK4qsPZJWRFkebeTBFneACVcqYGVWJVUFaqKIEufMZVNIbeyCCsrMgeTVmT+LlqReYAkyJIjJMjIOJSqQlXJayeWFUGWu+osyLIKMlTFV0WQkyiCTHL8/Hm8nY/3l9P2Wv7p7frw6fH8618v9ZP6vP7l9vxweny7nSQp1s84Tf4G","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"20":{"source":"use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub(crate) struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub(crate) fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub(crate) struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"std/hash/poseidon2.nr"},"50":{"source":"use common::{\n    check_commitment, check_input_note_ownership, get_address, get_note_commitment, InputNote, Note,\n};\nuse std::hash::poseidon2;\n\nmod test;\n\nfn main(\n    input_notes: [InputNote; 2],\n    output_notes: [Note; 2],\n    // TODO: rename to pmessage\n    pmessage4: Field,\n    commitments: pub [Field; 4],\n    messages: pub [Field; 6],\n) {\n    // Check the commitments\n    check_commitment(input_notes[0].note, commitments[0]);\n    check_commitment(input_notes[1].note, commitments[1]);\n    check_commitment(output_notes[0], commitments[2]);\n    check_commitment(output_notes[1], commitments[3]);\n\n    // Check individual outputs are not greater than 240 bits\n    output_notes[0].value.assert_max_bit_size::<240>();\n    output_notes[1].value.assert_max_bit_size::<240>();\n\n    // TODO: we need to check totals BY KIND\n\n    // We do not need to check the input notes values, as they must already have been added\n    // to the tree, and the only way for that to occur if them to be added as an output note first\n    // (which the check below would catch). Also, an overflow attack on the inputs would be deterimental\n    // to the attacker as they would have to provide more input funds, and would receive less output funds.\n    let input_value = input_notes[0].note.value + input_notes[1].note.value;\n\n    // Because we have already checked the individual output notes are no greater than 240 bits,\n    // then the maximum of the addition can be 2^241 which means the output value can never overflow\n    let output_value = output_notes[0].value + output_notes[1].value;\n\n    // If there are multiple kinds:\n    //  - there can be no padding notes\n    //  - input[i].kind == output[i].kind (i.e. no re-ordering of kinds allowed)\n    let is_input_multiple_kinds = is_multiple_kinds(input_notes[0].note, input_notes[1].note);\n\n    // Kind of UTXO txn (in future we may have subtypes for kind, which define different encodings\n    // but for now its easier to define this way, so bytes[32] will always be main kind)\n    let kind = messages[0];\n\n    // TODO: add this check back in (in agg_utxo proof)\n    // u8 (up to 5 bits, <=32)\n    // let kind_bytes = messages[0].to_be_bytes();\n    // let kind = kind_bytes[0];\n\n    // Messages (only for mint/burns, otherwise all zeros)\n    let msg_note_kind = messages[1];\n    let msg_value = messages[2];\n    // We only constrain the message hash for mints. For burns, any hash can be used\n    // as its only used by the substitutor to early release funds. Early release is\n    // secured by the validator, so as long as it records the burn hash it should be valid.\n    // A user could provide a burn hash that is already used, which would prevent\n    // a the substitutor from substituting the burn; this is acceptable.\n    let msg_hash = messages[3];\n    let burn_addr = messages[4];\n\n    // Mint hash - we use the private message to prevent others from\n    // being able to frontrun the mint hash in their own utxo txn\n    let mint_hash = poseidon2::Poseidon2::hash([output_notes[0].psi, output_notes[1].psi], 2);\n\n    // Burn hash - used for the burn substitutor and to verify status of an existing burn -\n    // could be any hash so long as its asserted in the proof and cannot be modified. We were\n    // planning to use the commitment of both inputs, but that is extra work and not neccessary.\n    let burn_hash = commitments[0];\n\n    if (kind == 1) {\n        //SEND\n        check_totals_match(input_value, output_value);\n\n        // Check the input/output values match\n        kinds_match(\n            is_input_multiple_kinds,\n            input_notes[0].note,\n            input_notes[1].note,\n            output_notes[0],\n            output_notes[1],\n        );\n    } else if (kind == 2) {\n        // MINT\n        // Check the second output note is padding or same kind\n        check_note_has_kind_or_padding(output_notes[1], output_notes[0].kind);\n        // Assert mint value\n        assert(output_value == input_value + msg_value, \"Mint output must match value message\");\n        // Assert mint hash\n        assert(mint_hash == msg_hash, \"Mint hash must match message\");\n        // Assert note kind\n        assert(output_notes[0].kind == msg_note_kind, \"Mint note kind must match message\")\n    } else if (kind == 3) {\n        // BURN\n        // Prevent frontrunning the txn and changing the evm address\n        assert(pmessage4 == burn_addr, \"messages[4] must match private input\");\n        // Assert burn hash\n        assert(burn_hash == msg_hash, \"Burn hash must match message\");\n        // Check the second input note is padding or same kind\n        assert(!is_input_multiple_kinds, \"Inconsistent input kind is not allowed for burn\");\n        // Assert burn value\n        assert(input_value == output_value + msg_value, \"Burn output must match value message\");\n        // Assert burn kind\n        assert(input_notes[0].note.kind == msg_note_kind, \"Burn note kind must match message\")\n    } else {\n        // TODO: should we create a contract kind?\n        assert(false, \"Invalid kind\");\n    }\n\n    // Check the user owns the input notes\n    check_input_note_ownership(input_notes[0]);\n    check_input_note_ownership(input_notes[1]);\n}\n\nfn is_multiple_kinds(note1: Note, note2: Note) -> bool {\n    if note2.kind == 0 {\n        false\n    } else {\n        note1.kind != note2.kind\n    }\n}\n\nfn check_totals_match(input_total: Field, output_total: Field) {\n    assert(input_total == output_total, \"Input and output totals do not match\");\n}\n\n/// Check the totals for each kind of note match on the inputs and outputs\nfn kinds_match(is_multiple_kinds: bool, input1: Note, input2: Note, output1: Note, output2: Note) {\n    if is_multiple_kinds {\n        assert(input1.kind == output1.kind, \"Inconsistent kind in input/output notes at 0 index\");\n        assert(input2.kind == output2.kind, \"Inconsistent kind in input/output notes at 1 index\");\n    } else {\n        assert(output1.kind == input1.kind, \"Inconsistent kind in note\");\n        check_note_has_kind_or_padding(output2, input1.kind)\n    }\n}\n\nfn check_note_has_kind_or_padding(note: Note, kind: Field) {\n    if note.kind != 0 {\n        assert(note.kind == kind, \"Inconsistent kind in note\");\n    }\n}\n\n#[test]\nfn test_send_two_inputs_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 1, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: 14, address, psi: 4 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_one_input_two_outputs() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 1, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: 9, address, psi: 4 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_two_inputs_one_output() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_diff_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 2, value: 5, address, psi: 4 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: 1, value: 30, address, psi: 3 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, 1, 10, mint_hash, 0, 0],\n    )\n}\n\n#[test]\nfn test_burn() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: 1, value: 10, address, psi: 3 };\n\n    // Commitments\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, 1, 10,  get_note_commitment(note_1), 0, 0],\n    )\n}\n\n#[test]\nfn test_send_zero_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - both zero value notes\n    let note_1 = Note { kind: 1, value: 0, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - both zero value notes\n    let note_3 = Note { kind: 1, value: 0, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_with_padding_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - one real note, one padding\n    let note_1 = Note { kind: 1, value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - note_3 is the first output (minted note), note_4 is padding or same kind\n    let note_3 = Note { kind: 1, value: 15, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, 1, 10, mint_hash, 0, 0],\n    )\n}\n\n#[test]\nfn test_burn_single_input() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - one real note, one padding\n    let note_1 = Note { kind: 1, value: 15, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - burn 10 value, keep 5\n    let note_3 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n    let note_4 = Note { kind: 1, value: 5, address, psi: 3 };\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [3, 1, 10, get_note_commitment(note_1), 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_different_kinds() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - mix of different kinds\n    let note_1 = Note { kind: 1, value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 3, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - mint kind 3, first note is the minted note\n    let note_3 = Note { kind: 3, value: 18, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, 3, 10, mint_hash, 0, 0],\n    )\n}\n\n#[test]\nfn test_send_large_values() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Test with larger values (but still within 240-bit constraint)\n    let large_value = 1000000000;\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: large_value, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: large_value, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: large_value + 500000, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: large_value - 500000, address, psi: 4 };\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_mint_same_kind() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Inputs - same kind\n    let note_1 = Note { kind: 2, value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 2, value: 10, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - mint more of same kind, first note is the minted note\n    let note_3 = Note { kind: 2, value: 25, address, psi: 3 };\n    let note_4 = Note { kind: 2, value: 0, address: 0, psi: 0 };\n\n    let commitments = [\n        get_note_commitment(note_1),\n        get_note_commitment(note_2),\n        get_note_commitment(note_3),\n        get_note_commitment(note_4),\n    ];\n\n    let mint_hash = poseidon2::Poseidon2::hash([note_3.psi, note_4.psi], 2);\n\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        commitments,\n        [2, 2, 10, mint_hash, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_input_first_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    // 2^240 = 1766847064778384329583297500742918515827483896875618958121606201292619776\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs - first note has overflow value\n    let note_1 = Note { kind: 1, value: overflow_value, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 10, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: 5, address, psi: 4 };\n\n    // This should fail due to overflow check on first input\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_input_second_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs - second note has overflow value\n    let note_1 = Note { kind: 1, value: 5, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: overflow_value, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs\n    let note_3 = Note { kind: 1, value: 10, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: 5, address, psi: 4 };\n\n    // This should fail due to overflow check on second input\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_output_first_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - first output has overflow value\n    let note_3 = Note { kind: 1, value: overflow_value, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: 5, address, psi: 4 };\n\n    // This should fail due to overflow check on first output\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test(should_fail)]\nfn test_overflow_output_second_note() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Create a value that exceeds 240 bits\n    let overflow_value = 1766847064778384329583297500742918515827483896875618958121606201292619777;\n\n    // Inputs\n    let note_1 = Note { kind: 1, value: 10, address, psi: 1 };\n    let note_2 = Note { kind: 1, value: 5, address, psi: 2 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: pk };\n\n    // Outputs - second output has overflow value\n    let note_3 = Note { kind: 1, value: 5, address, psi: 3 };\n    let note_4 = Note { kind: 1, value: overflow_value, address, psi: 4 };\n\n    // This should fail due to overflow check on second output\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n\n#[test]\nfn test_max_allowed_value() {\n    let pk: Field = 101;\n    let address = get_address(pk);\n\n    // Use a value that is exactly at the 240-bit limit (2^240 - 1)\n    let max_value = 1766847064778384329583297500742918515827483896875618958121606201292619775;\n\n    // Inputs - both notes have max allowed value\n    let note_1 = Note { kind: 1, value: max_value, address, psi: 1 };\n    let note_2 = Note { kind: 0, value: 0, address, psi: 0 };\n    let input_note_1 = InputNote { note: note_1, secret_key: pk };\n    let input_note_2 = InputNote { note: note_2, secret_key: 0 };\n\n    // Outputs - transfer to single output\n    let note_3 = Note { kind: 1, value: max_value, address, psi: 3 };\n    let note_4 = Note { kind: 0, value: 0, address, psi: 0 };\n\n    // This should succeed as the value is exactly at the limit\n    main(\n        [input_note_1, input_note_2],\n        [note_3, note_4],\n        0,\n        [\n            get_note_commitment(note_1),\n            get_note_commitment(note_2),\n            get_note_commitment(note_3),\n            get_note_commitment(note_4),\n        ],\n        [1, 0, 0, 0, 0, 0],\n    )\n}\n","path":"/Users/calummoore/projects/polybase/payy/noir/utxo/src/main.nr"},"52":{"source":"use std::hash::poseidon2;\n\npub struct Note {\n    pub kind: Field,\n    pub value: Field,\n    pub address: Field,\n    pub psi: Field,\n}\n\npub struct InputNote {\n    pub note: Note,\n    pub secret_key: Field,\n}\n\npub fn check_commitment(note: Note, commitment: Field) {\n    assert(get_note_commitment(note) == commitment, \"Note commitment is not valid\");\n}\n\npub fn get_note_commitment(note: Note) -> Field {\n    if (note.kind == 0) {\n        assert(note.value == 0, \"Padding notes must be zero value\");\n        0\n    } else {\n        poseidon2::Poseidon2::hash([note.kind, note.value, note.address, note.psi], 4)\n    }\n}\n\npub fn get_address(secret_key: Field) -> Field {\n    poseidon2::Poseidon2::hash([secret_key, 0], 2)\n}\n\npub fn check_input_note_ownership(input_note: InputNote) {\n    if (input_note.note.value != 0) {\n        assert(\n            get_address(input_note.secret_key) == input_note.note.address,\n            \"Input note is not owned by the owner\",\n        );\n    }\n}\n\npub fn slice<let N: u32, let L: u32>(bytes: [u8; N], start: u32) -> [u8; L] {\n    let end = start + L;\n    assert(end <= N, \"slice: slice end out of bounds\");\n    let mut result = [bytes[0]; L];\n    for i in 0..L {\n        result[i] = bytes[start + i];\n    }\n    result\n}\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        as_field += (bytes[i] as Field) * offset;\n        offset *= 256;\n    }\n    as_field\n}\n","path":"/Users/calummoore/projects/polybase/payy/noir/common/src/lib.nr"}},"names":["main"],"brillig_names":["directive_invert"]}